<!doctype html>
<html>

<body>
    <canvas width="570" height="570" id="my_Canvas"></canvas>

    <script>
        /*============== Creating a canvas ====================*/
        var canvas = document.getElementById('my_Canvas');
        gl = canvas.getContext('experimental-webgl');

        /*======== Defining and storing the geometry ===========*/
        const profundidad = 1+Math.floor(Math.random()*10);
        console.log(profundidad)

        const ax = 0.0, ay = 1.0;
        const bx = -1.0, by = -1.0;
        const cx = 1.0, cy = -1.0;

        const vertices = [];      
        const indices = [];     
        const pos2idx = new Map();

        const getIndex = (x, y) => {
            const key = `${x},${y}`;
            let idx = pos2idx.get(key);
            if (idx !== undefined) return idx;
            idx = vertices.length / 2;
            vertices.push(x, y);
            pos2idx.set(key, idx);
            return idx;
        };

        const Sierpinski = (ax, ay, bx, by, cx, cy, lvl) => {
            if (lvl === 1) {
                const ia = getIndex(ax, ay);
                const ib = getIndex(bx, by);
                const ic = getIndex(cx, cy);
                indices.push(ia, ib, ic);
                return;
            }
            const abx = (ax + bx) / 2, aby = (ay + by) / 2;
            const bcx = (bx + cx) / 2, bcy = (by + cy) / 2;
            const cax = (cx + ax) / 2, cay = (cy + ay) / 2;

            // Tres tri√°ngulos de las esquinas (se omite el central)
            Sierpinski(ax, ay, abx, aby, cax, cay, lvl - 1);
            Sierpinski(bx, by, bcx, bcy, abx, aby, lvl - 1);
            Sierpinski(cx, cy, cax, cay, bcx, bcy, lvl - 1);
        };

        Sierpinski(ax, ay, bx, by, cx, cy, profundidad);

        // Create an empty buffer object to store vertex buffer
        var vertex_buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Create an empty buffer object to store Index buffer
        var Index_Buffer = gl.createBuffer();

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Pass the vertex data to the buffer
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Unbind the buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        /*================ Shaders ====================*/

        // Vertex shader source code
        var vertCode =
            'attribute vec2 coordinates;' +

            'void main(void) {' +
            ' gl_Position = vec4(coordinates,0.0, 1.0);' +
            '}';

        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        gl.shaderSource(vertShader, vertCode);

        // Compile the vertex shader
        gl.compileShader(vertShader);

        //fragment shader source code
        var fragCode =
            'void main(void) {' +
            ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        gl.shaderSource(fragShader, fragCode);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both the programs
        gl.linkProgram(shaderProgram);

        // Use the combined shader program object
        gl.useProgram(shaderProgram);

        /*======= Associating shaders to buffer objects =======*/

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Bind index buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

        // Get the attribute location
        var coord = gl.getAttribLocation(shaderProgram, "coordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coord);

        /*=========Drawing the triangle===========*/

        // Clear the canvas
        gl.clearColor(0.5, 0.5, 0.5, 0.9);

        // Enable the depth test
        gl.enable(gl.DEPTH_TEST);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Draw the triangle
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    </script>
</body>

</html>